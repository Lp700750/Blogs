## 结构体的对齐
### 0 前言
>结构体里面可能会包含有各种成员变量，那么对于他们定义顺序的不同，他们在内存当中的存储空间是不是一样的呢？今天就让我们来看看结构体的对齐规则与其作用。
### 1 对齐规则
>- 第一个成员在与结构体变量偏移量为0的地址处。
>- 其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处。对齐数=编译器默认的一个对齐数与该成员大小的较小值。VS中默认的值为8
>- 结构体总大小为min(最大对齐数(每个成员变量都有一个对齐数),编译器默认的对齐数)的整数倍。
>- 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处,结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。        
    
**举一个栗子**
```
struct s1
{
    char c1;
    int i;
    char c2;
};
struct s2
{
    char c1;
    char c2;
    int 1;
};
``` 
![image](https://github.com/Lp700750/Blogs/assets/104414865/80c0f2f3-fffe-4e2c-a5eb-03a310445e87)
修改编译器的默认的对齐数
```
#pragma back(8)  //修改默认对齐数为8
#pragma back()   //取消默认的对齐数，还原成默认值
``` 
### 2 对齐的原因
>- 平台原因(移植原因): 不是所有的硬件平台都能访问任意地址上的任意数据的;某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
>- 性能原因:数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存,处理器需要作两次内存访问;而对齐的内存访问仅需要一次访问。  
>- 简单来说就是用**空间来换时间**
