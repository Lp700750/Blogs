# TCP可靠机制_1

### **检验和**

>- tcp校验需要将ip伪首部、tcp报头、tcp数据分为16位的字，然后进行累加（如果总长度为奇数个字节，则在最后增添一个位都为0的字节 ），最后对累加的和进行按位取反即可。
>- 这个16位的检验和是由发送端进行填写，然后由CRC进行校验，如果接收端的校验不通过，那就表明数据有问题。

### 序列号

>- TCP由于是面向字节流的，因此再进行传输的时候，它会将数据给按照字节流的形式进行传输，在这里每个发送请求的主机会给每个字节的数据分配一个序号，同时这里的序号不仅可以标识每一个数据，同时还让每一个数据进行有序的在字节流当中，便于主机AB的传输和收发。
>
>![image](https://github.com/Lp700750/Blogs/assets/104414865/bc9f86b1-1bd1-45e0-a11d-b9c409ff53f3)


### 确认应答

>- 而确认应答一般是反馈主机面对请求主机发送的一种序号，一般和ACK确认标志位一起使用，这里确认应答的序号一般是在请求端发来的序号基础之上＋1，但是确认应答的深层含义是：反馈主机收到的确认序号，也就意味这在这个序号之前所有序号的数据已经确认收到，之后的序号目前还不能够确认
>- TCP的确认应答机制是对历史数据的确认，对于当前数据是不能够进行确认的
>
>- 由于TCP对于最后一条确认ACK不能够保证其是否遗失，因此TCP 协议也不是100%可靠的，他只是对于历史的数据100%可靠

### **超时重传**

>- 在进行数据传输的过程当中，主机A给主机B发送数据，这时可能会面临两个问题
>
>1. 发送的数据在网络当中遗失
>2. 主机B发送的确认标志位丢失
>
>- 面对丢失的数据，主机A迟迟收不到来自主机B的确认ACK，这时TCP该怎么做？这时TCP就会采用超时重传机制
>
>1. Linux中，超时以500ms为一个单位进行控制，每次判定重传时间都是500ms的整数倍。
>2. 如果重发一次没有得到响应，会等待2×500ms进行重传**。**
>3. 如果仍没有得到应答，等待4×500ms进行重传，依次类推，以指数形式增长。
>4. 但是累计到一定次数的重传次数，TCP会认为对方主机或者网络出现异常，会强制关闭连接。
>
>- 这里如果是主机B的确认ACK丢失的话，主机A会频繁的给主机B发送相同的数据，这时序列号的作用就会体现出来，当该数据的序号已经被主机B给确认过之后，主机A再发的数据就会被主机B给丢弃掉，达到一个去重的目的。
