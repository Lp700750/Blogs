# 右值引用

### **何为左值？何又为右值？**

>- 如果表达式的结果是一个临时变量或者对象则将其看作右值
>- 如果表达式的结果是单个变量或者是一个引用则将其看作左值
>- 在C/C++当中一般将能够取地址的对象叫做左值，将那些不能够取地址的对象叫做右值
>- const的变量虽然是可读不可修改，但是由于其可以去地址因此还将其看作左值(如果只是const的类型定义的时候，编译器是不开空间的，如果对该常量取地址时才为其开辟空间)
>- C/C++对右值进行了严格的区分
>  - C语言当中的纯右值 10，a+b
>  - 将亡值，表达式当中的中间结果，函数按照值得方式的返回值

>```C++
>int a=1;//常见的左值
>10;
>x+y;      //临时变量
>func(x,y);//这几个都是常见的右值
>```
>
>- ##### **引用？**
>
>  - 引用就是取别名，在表层上面来理解引用的变量与引用的实体是共用一块内存空间的，在底层来看他们是通过指针来进行实现的，提高了代码的可读性。
>  - *C98*当中的普通引用只能引用左值，*const*的引用可以引用左值的同时也可以引用右值
>  - *C11*当中可以引用右值，但是一般不会直接用右值引用引用左值
>
### **左值引用和右值引用的地址空间区别**
>
>  - **左值引用：在引用之前，引用的实体就已经有了一块空间，左值引用之后引用的实体和引用的变量共用一块空间**
>  - **右值引用：在引用之前，引用的实体没有开辟空间，右值引用之后系统为引用的变量开辟一块空间**

### ***C++11*引入右值的目的是在干嘛呢？**

>上面讲过，在C++98当中已经可以使用const来进行引用左值或者 右值，那么为什么还要引入右值引用呢?原因我们认为有两个：
>
>- 在函数当中返回一个值的时候，如果这个值除了函数的作用域就被销毁了，那么这里就不能够使用左值引用了，只能够进行传值返回，那么这里就会增加耗费的资源
>- 左值引用说到底还是进行拷贝构造，对于那么资源比较庞大的变量来说，进行深拷贝就需要耗费很大的精力来实现，然后右值引用就不一样，他在底层使用转移资源的方式来进行，虽然说装有资源外壳被销毁了，但是其内部的资源已经被转移，他还继续”活着“，这对于编辑器来说是一件莫大的好事，提高了效率。

### 左值引用与右值引用的对比

>![右值引用](https://github.com/Lp700750/Blogs/assets/104414865/d7607cba-ecdf-4b11-896a-3c5b1219399e)
>
>**看上面得到图可以知道，在进行调用拷贝构造时，当是左值传入时就是调用拷贝构造，但是如果是值进行了*move*后就变成了右值，调用的时候就会调移动构造，*move*的作用>就是变成右值的同时进行资源的转移这里我们可以看到s的资源转移到s2里面之后s里面就变成了空*nullptr*。**
>
>![右值引用_只有拷贝构造时](https://github.com/Lp700750/Blogs/assets/104414865/fb36ca5c-0f2f-48b9-b39e-f6e92346f64f)
>
>	**在*C++98*的时候没有引入右值引用的时候，那时候在函数里面返回一个局部变量的时候，由于出了作用域就会被销毁，于是这里的用*str*先拷贝构造一个临时变量，然后再用>这个临时变量拷贝构造传给*ret*，只不过编译器会进行优化，直接将*str*拷贝构造传给*ret*。**
>
>![右值引用_拷贝构造+移动构造时](https://github.com/Lp700750/Blogs/assets/104414865/d47c11fc-9bc8-4e3f-8d44-dedceebd6709)
>
>
>	**在引入了*C++11*之后，随着右值引用的进入，在这里就发生了变化不再只有拷贝构造了，因为在这里str有地址，所以第一次引用时左值引用，第二次由于是临时变量，所>以第二次引用就是右值引用，但是编译器会进行优化，所以就直接将*str*看作一个将亡值，直接一次移动构造就完成了。**
>
>![右值引用_没有返回值](https://github.com/Lp700750/Blogs/assets/104414865/7061d91c-22a8-434c-952e-9443c645362c)
>
>
>​		**但是当出现上面没有新定义*ret*的这种情况的时候，就只有一次拷贝构造了，此时编译器也不会进行优化，因为此时已经没有了优化的空间了。**
>![右值引用_底层没有右值引用](https://github.com/Lp700750/Blogs/assets/104414865/65ff35e9-9953-495c-b0f7-38be19f944f5)
>
>
>![右值引用_底层有右值引用](https://github.com/Lp700750/Blogs/assets/104414865/bc5c9b7e-2f32-40c7-bd91-b7b01c8d1aa8)
>
>
>**在*C++11*之后容器插入接口，都会多提供一个右值引用的版本，与*`C++98`*不同，在*C++11*之后如果传过来的是一个右值的话，那么就会调用底层的移动构造和赋值，进>行右值的引用，没有时才调用深拷贝**
>
### 其他的接口
>
>除了上面的拷贝构造和赋值重载，C++ 还将其他许多的容器接口都添加了右值引用，它可以提高效率，但是这里面需要注意的一点就是右值引用左值的时候在底层会将变量的内部资源进行转移，这也就意味了原始的变量将会变成空，这时我们就不能够在对这些对象进行访问了。

### 完美转发

>```C++
>temp1ate <typename T>
>void PerfectForward(T&&t)
>{
>    Fun(t);
>}
>```
>
>在其他的地方使用的时候，&&代表的是进行右值引用，但是如果是在模板的地方使用，那么这里就是完美转发了，也就是说此时这里既可以引用左值，又可以引用右值，加入这里引用的是右值，那么后面会发生什么呢？
>
>上面说过，右值引用对象时，虽然该对象不能够取地址，但是如果右值引用完毕之后，会给该资源赋予一个地址放着。那么在完美转发这里就出现了问题，因为完美转发接收右值，然后下面的函数处理这个右值引用过来的资源时，发现他有了地址进行储存着，那么这里在使用它时，会把它当作左值，继而使用左值引用，这时可能就不是我们想看到的了，这时该怎么避免这种情况呢？
>
>```C++
>temp1ate <typename T>
>void PerfectForward(T&&t)
>{
>    Fun(std:: forward<T>(t));
>}
>```
>
>很简单，这时只需要在函数调用该右值的时候，加上一个forward<T>就行，这样就可以保留它的原始右值属性了。
