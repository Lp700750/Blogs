#  特殊关键字的含义与使用

## 0 前言

> 在C++语言当中，我们可能会见到许多的关键字，许多可能会印象深刻，但是有些我们可能没怎么见过，这次我们就来列出那些我们没怎么见过的关键字，了解他们背后的含义与使用。

## 1 特殊关键字

### 1.1 dynamic_cast

>- dynamic_cast是四个强制类型转换操作符中最特殊的一个，**它支持运行时识别指针或引用**。
>
>- 首先，dynamic_cast依赖于RTTI信息，其次，在转换时，dynamic_cast会检查转换的source对象是否真的可以转换成target类型，这种检查不是语法上的，而是真实情况的检查。
>
>- dynamic_cast主要用于“安全地向下转型”
>
>- dynamic_cast**用于类继承层次间的指针或引用转换**。主要还是用于执行“安全的向下转型（safe downcasting）”，也即是基类对象的指针或引用转换为同一继承层次的其他指针或引用。
>
>- 至于“先上转型”（即派生类指针或引用类型转换为其基类类型），本身就是安全的，尽管可以使用dynamic_cast进行转换，但这是没必要的， 普通的转换已经可以达到目的，**毕竟使用dynamic_cast是需要开销的**。

### 1.2 static_cast

> - static_cast <要转换到的类型> (待转换的表达式)
>
> - static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。
> - static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。 

### 1.3 const_cast

>  const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。 

### 1.4 reinterpret_cast

> - reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。
>
> - 这种转换提供了很强的灵活性，但转换的安全性只能由我们执行人员来保证了。例如，当我们执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，也只能由我们自行承担查找错误的工作了

### 1.5 typeid

> - typeid是c++的一个关键字，typeid操作符的返回结果是标准库类型type_info对象的引用。
> - 但是，C++标准并没有明确定义type_info，其具体实现依赖于各个编译器。标准只规定了typeid操作符必需实现如下操作
>
> ```C++
> int a=10;
> typeid(a)==typeid(int);
> typeid(a).name   // int
> ```
>
> | 操作     | 说明                                                         |
> | -------- | ------------------------------------------------------------ |
> | t1 == t2 | 如果两个对象t1和t2类型相同，则返回true；否则返回false        |
> | t1 != t2 | 如果两个对象t1和t2类型不同，则返回true；否则返回false        |
> | t.name() | 返回类型的C-style字符串。由编译器决定，不一定就是真实的类型名 |

### 1.6 throw

> - 在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：
>
> ```C++
> throw exceptionData;
> ```
>
> - exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。

### 1.7 wchar_t

>- 传统的字符数据类型为char,占用一个字节,存放的数据内容为ASCII编码,最多可以存放255种字符,基本的英文以及常用字符都可以涵盖
>
>- 随着计算机在国际范围内普及,大量使用其它语言的计算机用户也纷纷出现,传统的ASCII编码已经无法满足人们的使用,因此一种新的字符存放类型wchar_t应运而生
>
>- wchar_t为宽字符类型或双字符类型,它占用两个字节,因此能够存放更多的字符

### 1.8 explicit

> [参考](https://blog.csdn.net/qq_35524916/article/details/58178072)
>
> - C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用。
>
> - C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 
>   - 1 是个构造
>   - 2 是个默认且隐含的类型转换操作符。
>
> - 所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。
>
> - 这样看起来好象很酷， 很方便。 但在某些情况下， 却违背了程序员的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。
>
> 解析：explicit构造函数是用来防止隐式转换的。请看下面的代码：
>
> ```C++
> #include <iostream>
> using namespace std;
> class Test1
> {
> public :
> 	Test1(int num):n(num){}
> private:
> 	int n;
> };
> class Test2
> {
> public :
> 	explicit Test2(int num):n(num){}
> private:
> 	int n;
> };
> 
> int main()
> {
> 	Test1 t1 = 12;
> 	Test2 t2(13);
> 	Test2 t3 = 14;
> 
> 	return 0;
> }
> ```
>
> - 编译时，会指出 t3那一行error:无法从“int”转换为“Test2”。而t1却编译通过。注释掉t3那行，调试时，t1已被赋值成功。
>
> - 注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。

### 1.9 catch

>使用try和catch捕获异常：
>
>```C++
>try{
>	...//保护代码
>}catch(Ex e1){
>	...//异常处理
>}catch(Ex e2){
>	...//异常处理
>}catch(Ex eN){
>	...//异常处理
>}
>```
>
>- try块后面通常跟着1个或多个catch块，用于捕获保护代码里可能抛出的异常。当保护代码抛出异常后，程序将跳出try块（即使在另一个函数域中），并在catch块中寻找关于该异常的处理办法，Ex e中Ex即抛出异常的类型，e即处理异常中对异常的称呼（类似函数的参数）

### 1.10 mutable

>- mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。
>
>- 在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
>
>- 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰 

### 1.11 register

>**对于register关键字：**
>
>- register关键字只能作用于局部变量，不能作用于全局变量。
>- register关键字指明将局部变量存储于寄存器中。
>- register只是请求寄存器变量，但不一定请求成功。
>- register变量的必须是CPU寄存器可以接受的值。
>- 不能用&运算符获取register变量的地址。
>
>```C++
>#include <stdio. h>
>register int g_ var; // 错误
>int main()
>{
>	register char var;
>	print("%p\n", &var); //错误
>	return 0;
>}
>```

### 1.12 extern

>###### extern修饰变量和函数
>
>- 在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。
>
>- 也就是说，在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：
>  - 使用头文件，然后声明它们，然后其他文件去包含头文件
>  - 在其他文件中直接extern
>
>- 比如说你用C 开发了一个DLL 库，为了能够让C ++语言也能够调用你的DLL 输出(Export) 的函数，你需要用extern "C" 来强制编译器不要修改你的函数名。 
>
>-  现在要写一个c语言的模块，供以后使用（以后的项目可能是c的也可能是c++的），源文件事先编译好，编译成.so或.o都无所谓。头文件中声明函数时要用条件编译包含起来，如下：
>
> ```C++
>#ifdef __cpluscplus  
>extern "C" 
>{  
>#endif  
>
>//some code  
>
>#ifdef __cplusplus  
>}  
>#endif 
> ```
